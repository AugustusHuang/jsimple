;;;; The MIT License (MIT)

;;;; Copyright (c) 2015 Huang Xuxing

;;;; Permission is hereby granted, free of charge, to any person obtaining
;;;; a copy of this software and associated documentation files
;;;; (the "Software"), to deal in the Software without restriction,
;;;; including without limitation the rights to use, copy, modify, merge,
;;;; publish, distribute, sublicense, and/or sell copies of the Software,
;;;; and to permit persons to whom the Software is furnished to do so,
;;;; subject to the following conditions:

;;;; The above copyright notice and this permission notice shall be included
;;;; in all copies or substantial portions of the Software.

;;;; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
;;;; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
;;;; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
;;;; THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
;;;; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
;;;; ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
;;;; OTHER DEALINGS IN THE SOFTWARE.

;;;; Intermediate representation handling and optimizing module.
;;;; After parsing we get a list of abstract syntax tree whose CAR is :js,
;;;; now we need to translate this AST into an intermediate representation
;;;; of functional style. Then do some early optimization to the IR and get
;;;; to the final stage: compile the IR into optimized Lisp code (with type
;;;; and optimize level) and evaluate to result.
(in-package :jsimple-ir)

;;; NODIFY-JS reads the AST generated by PARSE-JS or PARSE-JS-STRING,
;;; and return a sequence of NODEs, which optimizer operates on.
(defun nodify-js (ast)
  (assert (eql (car ast) :js)
	  ast
	  ("Broken ast."))
  (let ((statements (cadr ast)))
    (dolist (statement statements)
      (case statement
	;; Variable definitions.
	(:let ())
	(:var ())
	(:const ())
	;; Function definition, maybe anonymous or named function.
	(:defun ())
	;; Built-in types.
	(:class ())
	(:array ())
	(:string ())
	(:object ())
	;; Pure statement, can be evaluated, will contain operations.
	(:stat ())
	;; General blocks, start a new local scope.
	(:block ())
	;; Loops.
	(:do ())
	(:for ())
	(:for-in ())
	(:for-of ())
	(:while ())
	;; Return.
	(:return ())
	;; Conditional type, es only have if, switch.
	(:if ())
	(:switch ())
	;; Jump code, only appear within a block.
	(:break ())
	(:continue ())
	;; Assignment, counterpart of SETF or SETQ in Common Lisp.
	(:assign ())
	;; Error handling.
	(:catch ())
	(:try ())
	(:throw ())))))

;;; OPTIMIZE-js reads the NODE sequence generated by NODIFY-JS and make
;;; modifications like deleting unused nodes, logic solving and type inference.
;;; It will die if one of the states is reached, or it will loop.
(defun optimize-js (node-sequence)
  )
