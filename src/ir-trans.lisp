;;;; The MIT License (MIT)

;;;; Copyright (c) 2015 Huang Xuxing

;;;; Permission is hereby granted, free of charge, to any person obtaining
;;;; a copy of this software and associated documentation files
;;;; (the "Software"), to deal in the Software without restriction,
;;;; including without limitation the rights to use, copy, modify, merge,
;;;; publish, distribute, sublicense, and/or sell copies of the Software,
;;;; and to permit persons to whom the Software is furnished to do so,
;;;; subject to the following conditions:

;;;; The above copyright notice and this permission notice shall be included
;;;; in all copies or substantial portions of the Software.

;;;; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
;;;; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
;;;; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
;;;; THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
;;;; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
;;;; ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
;;;; OTHER DEALINGS IN THE SOFTWARE.

;;;; Intermediate representation handling and optimizing module.
;;;; After parsing we get a list of abstract syntax tree whose CAR is :js,
;;;; now we need to translate this AST into an intermediate representation
;;;; of functional style. Then do some early optimization to the IR and get
;;;; to the final stage: compile the IR into optimized Lisp code (with type
;;;; and optimize level) and evaluate to result.
(in-package :jsimple-ir)

;;; Go deeper, push a new 1 to the tail, go further, increment last element.
(declaim (list *ast-pos*))
(defvar *ast-pos* nil)

;;; PIECE we currently live, will become NIL sometime in optimization.
(declaim (type (or piece null) *current-piece*))
(defvar *current-piece* nil)

;;; Call PUSH-OR-GO with T means do the former, else do the later.
(defun push-or-go (which)
  (declare (type boolean which))
  (if which
      ;; PUSH
      (flet ((push-back (lst obj)
	       (let ((rlst (reverse lst)))
		 (reverse (push obj rlst)))))
	(push-back *ast-pos* 1))
      ;; GO
      (incf (car (last *ast-pos*)))))

;;; NODIFY-JS reads the AST generated by PARSE-JS or PARSE-JS-STRING,
;;; and return a sequence of NODEs, which optimizer operates on.
(defun nodify-js (ast)
  (assert (eql (car ast) :js)
	  ast
	  ("Broken AST."))
  (let ((statements (cadr ast)))
    (dolist (statement statements)
      (case (car statement)
	;; Variable definitions.
	(:let ())
	(:var ())
	(:const ())
	;; Function definition, maybe anonymous or named function.
	(:defun ())
	;; Built-in types.
	(:class ())
	(:array ())
	(:string ())
	(:object ())
	;; Pure statement, can be evaluated, will contain operations.
	(:stat ())
	;; General blocks, start a new local scope.
	(:block ())
	;; Loops.
	(:do ())
	(:for ())
	(:for-in ())
	(:for-of ())
	(:while ())
	;; Return.
	(:return ())
	;; Conditional type, es only have if, switch.
	(:if ())
	(:switch ())
	;; Jump code, only appear within a block.
	(:break ())
	(:continue ())
	;; Assignment, counterpart of SETF or SETQ in Common Lisp.
	(:assign ())
	;; Error handling.
	(:catch ())
	(:try ())
	(:throw ())))))

