
;;;; Parser package.
(in-package :jsimple-parser)

;;; Parser helper functions.
;; Select the second argument.
(defun snd (f s &rest args)
  (declare (ignore f args))
  s)

;; Push element, become the tail of current list.
(defun push-tail-2 (lst obj)
  (let ((out (reverse lst)))
    (reverse (push obj out))))

(defun push-tail (lst &rest objs)
  (let ((out lst))
    (dolist (obj objs)
      (setf out (push-tail-2 out obj)))
    out))

;; Choose interested arguments and ignore the others, the arguments are applyed
;; in sequence. Return a function which will accept needed arguments.
;; NOTE: Index count from 0.
;(defmacro with-choice (function total &rest indices)
;  (let* ((0-to-n-1 (loop for i from 0 to (1- total) collect i))
;	 (handle-list indices)
;	 (ignore-list 0-to-n-1))
;    (dolist (index handle-list)
;      (setf ignore-list (remove index ignore-list)))
;    ))

;; Parser generated by LISPBUILDER-YACC.
(define-parser *jsimple-parser*
    (:start-symbol program)
  (:terminals
   (numeric
    string
    identifier
    regex
    + ++ - --
    * / %
    += -= *= /= %= = == === != !==
    > < >= <= << >> <<= >>= >>> >>>=
    && || ~ &= |= ^= , : |;|
    |(| |)| { }
    break do in typeof case else instanceof var catch export new void class
    extends return while const finally super with continue for switch yield
    debugger function this default if throw delete import try))
  
  (statement
   block-statement
   variable-statement
   empty-statement
   expression-statement
   if-statement
   iteration-statement
   continue-statement
   break-statement
   return-statement
   with-statement
   labelled-statement
   switch-statement
   throw-statement
   try-statement
   debugger-statement)

  (block-statement
   ({ statement-list } (lambda (a b c)
			 (declare (ignore a c))
			 (funcall #'build-block-statement b))))

  (statement-list
   (statement-list statement #'push-tail-2)
   nil)

  (variable-statement
   (var variable-declaration-list (lambda (a b)
                                    (declare (ignore b))
                                    (funcall #'build-variable-declaration a))))

  (variable-declaration-list
   (variable-declaration)
   (variable-declaration-list , variable-declaration (lambda (a b c)
                                                       (declare (ignore b))
                                                       (funcall #'push-tail-2 a c))))

  (variable-declaration-list-no-in
   (variable-declaration-no-in)
   (variable-declaration-list-no-in , variable-declaration-no-in
     (lambda (a b c)
       (declare (ignore b))
       (funcall #'push-tail-2 a c))))

  (variable-declaration
   (identifier #'build-variable-declaration)
   (identifier initializer #'build-variable-declaration))

  (variable-declaration-no-in
   (identifier #'build-variable-declaration)
   (identifier initializer-no-in #'build-variable-declaration))

  (initializer
   (= assignment-expression #'snd))

  (initializer-no-in
   (= assignment-expression-no-in #'snd))

  (empty-statement
   (|;| #'build-empty-statement))

  (expression-statement
   (expression-no-bf |;| (lambda (a b)
			   (declare (ignore b))
			   (funcall #'build-expression-statement a)))
   (expression-no-bf error (lambda (a b)
			     (declare (ignore b))
			     (funcall #'build-expression-statement a))))

  (if-statement
   (if { expression } statement (lambda (a b c d e)
				  (declare (ignore a b d))
				  (funcall #'build-if-statement c e)))
   (if { expression } statement else statement (lambda (a b c d e f g)
						 (declare (ignore a b d f))
						 (funcall #'build-if-statement c e g))))

  (iteration-statement
   (do statement while |(| expression |)| |;| #'build-do-while-statement)
   (do statement while |(| expression |)| error #'build-do-while-statement)
   (while |(| expression |)| statement #'build-while-statement)
   (for |(| expression-no-in |;| expression |;| expression |)| statement #'build-for-statement)
   (for |(| expression-no-in |;| expression |;| |)| statement #'build-for-statement)
   (for ( expression-no-in #\; #\; expression ) statement #'build-for-statement)
   (for ( expression-no-in #\; #\; ) statement #'build-for-statement)
   (for ( #\; expression #\; expression ) statement #'build-for-statement)
   (for ( #\; expression #\; ) statement #'build-for-statement)
   (for ( #\; #\; expression ) statement #'build-for-statement)
   (for ( #\; #\; ) statement #'build-for-statement)
   (for ( var variable-declaration-list-no-in #\; expression #\; expression ) statement #'build-for-statement)
   (for ( var variable-declaration-list-no-in #\; expression #\; ) statement #'build-for-statement)
   (for ( var variable-declaration-list-no-in #\; expression ) statement #'build-for-statement)
   (for ( var variable-declaration-list-no-in #\; ) statement #'build-for-statement)
   (for ( left-hand-side-expression in expression ) statement #'build-for-in-statement)
   (for ( var variable-declaration-no-in in expression ) statement #'build-for-in-statement))

  (continue-statement
   (continue #\; #'build-continue-statement)
   (continue error #'build-continue-statement)
   (continue identifier #\; #'build-continue-statement)
   (continue identifier error #'build-continue-statement))

  (break-statement
   (break #\; #'build-break-statement)
   (break error #'build-break-statement)
   (break identifier #\; #'build-break-statement)
   (break identifier error #'build-break-statement))

  (return-statement
   (return #\; #'build-return-statement)
   (return error #'build-return-statement)
   (return expression #\; #'build-return-statement)
   (return expression error #'build-return-statement))

  (with-statement
   (with ( expression ) statement #'build-with-statement))

  (switch-statement
   (switch ( expression ) case-block #'build-switch-statement))

  (case-block
   ({ case-clauses } #'snd-3)
   ({ case-clauses default-clause case-clauses } #'push-3))

  (case-clauses
   (case-clauses case-clause #'push-2)
   nil)

  (case-clause
   (case expression : statement-list #'build-switch-case))

  (default-clause
   (default : statement-list #'build-switch-case))

  (labelled-statement
   (identifier : statement #'build-labelled-statement))

  (throw-statement
   (throw expression #\; #'build-throw-statement)
   (throw expression error #'build-throw-statement))

  (try-statement
   (try block-statement catch #'build-try-statement)
   (try block-statement finally #'build-try-statement)
   (try block-statement catch finally #'build-try-statement))

  (catch
   (catch ( identifier ) block-statment #'build-catch-clause))

  (finally
   (finally block-statement #'snd-2))

  (debugger-statement
   (debugger #\; #'build-debugger-statement)
   (debugger error #'build-debugger-statement))

  (function-declaration
   (function identifier ( ) { function-body } #'build-function-declaration)
   (function identifier ( formal-parameter-list ) { function-body } #'build-function-declaration))

  (function-expression
   (function identifier ( ) { function-body } #'build-function-expression)
   (function identifier ( formal-parameter-list ) { function-body } #'build-function-expression)
   (function ( ) { function-body } #'build-function-expression)
   (function ( formal-parameter-list ) { function-body } #'build-function-expression))

  ; TODO: Is hashtable really required?
  (formal-parameter-list
   (identifier #'build-identifier)
   (formal-parameter-list , identifier #'push-2))

  (function-body
   source-elements)

  (program
   (source-elements ;;EOF
    #'build-program))
  
  (source-elements
   (source-elements source-element #'push-2)
   nil)

  (source-element
   statement
   function-declaration)

  (primary-expression
   primary-expression-no-brace
   object-literal)

  (primary-expression-no-brace
   (this #'build-this-expression)
   (identifier #'build-identifier)
   (literal)
   (array-literal)
   ({ expression } #'snd-3))

  (array-literal
   ([ ] #'build-array-expression)
   ([ elision ] #'build-array-expression)
   ([ element-list ] #'build-array-expression)
   ([ element-list , ] #'build-array-expression)
   ([ element-list , elision ] #'build-array-expression))

  (element-list
   (assignment-expression #'list)
   (elision assignment-expression #'push-2)
   (element-list , assignment-expression #'push-2)
   (element-list , elision assignment-expression #'push-3))

  (elision
   (, #'null-list)
   (elision , #'push-2))

  (object-literal
   ({ } #'build-object-expression)
   ({ property-name-and-value-list } #'build-object-expression)
   ({ property-name-and-value-list , } #'build-object-expression))

  (property-name-and-value-list
   (property-assignment #'list)
   (property-name-and-value-list , property-assignment #'push-2))

  (property-assignment
   (property-name : assignment-expression #'build-property)
   ; How to tell difference between getter and others?
   (identifier property-name ( ) { function-body } ;;
       )
   ; And setter...
   (identifier property-name ( property-set-parameter-list ) { function-body } ;;
       ))

  (property-name
   identifier-name
   string-literal
   numeric-literal)

  (property-set-parameter-list
   (identifier #'build-identifier))

  (member-expression
   primary-expression
   function-expression
   (member-expression [ expression ] #'build-member-expression)
   (member-expression . identifier #'build-member-expression)
   (new member-expression arguments #'build-member-expression))

  (member-expression-no-bf
   primary-expression-no-brace
   (member-expression-no-bf [ expression ] #'build-member-expression)
   (member-expression-no-bf . identifier #'build-member-expression)
   (new member-expression arguments #'build-member-expression))

  (new-expression
   member-expression
   (new new-expression #'build-new-expression))

  (new-expression-no-bf
   member-expression
   (new new-expression #'build-new-expression))

  (call-expression
   (member-expression arguments #'build-call-expression)
   (call-expression arguments #'build-call-expression)
   (call-expression [ expression ] #'build-member-expression)
   (call-expression . identifier #'build-member-expression))

  (call-expression-no-bf
   (member-expression-no-bf arguments #'build-call-expression)
   (call-expression-no-bf arguments #'build-call-expression)
   (call-expression-no-bf [ expression ] #'build-member-expression)
   (call-expression-no-bf . identifier #'build-member-expression))

  (id
   (identifier #'build-identifier)
   (reserved-word #'build-identifier))

  (arguments
   (( ) nil)
   (( argument-list ) #'snd-3))

  (argument-list
   (assignment-expression #'list)
   (argument , assignment-expression #'push-2))

  (left-hand-side-expression
   new-expression
   call-expression)

  (left-hand-side-expression-no-bf
   new-expression-no-bf
   call-expression-no-bf)

  (postfix-expression
   left-hand-side-expression
   (left-hand-side-expression ++ #'build-update-expression)
   (left-hand-side-expression -- #'build-update-expression))

  (postfix-expression-no-bf
   left-hand-side-expression-no-bf
   (left-hand-side-expression-no-bf ++ #'build-update-expression)
   (left-hand-side-expression-no-bf -- #'build-update-expression))

  (unary-expression
   postfix-expression
   unary-expr)

  (unary-expression-no-bf
   postfix-expression-no-bf
   unary-expr)

  (unary-expr
   (delete unary-expression #'build-unary-expression)
   (void unary-expression #'build-unary-expression)
   (typeof unary-expression #'build-unary-expression)
   ; FIXME: Update the position!
   (br++ unary-expression #'build-unary-expression)
   (br-- unary-expression #'build-unary-expression)
   (++ unary-expression #'build-unary-expression)
   (-- unary-expression #'build-unary-expression)
   (+ unary-expression #'build-unary-expression)
   (- unary-expression #'build-unary-expression)
   (~ unary-expression #'build-unary-expression)
   (! unary-expression #'build-unary-expression))

  (multiplicative-expression
   unary-expression
   (multiplicative-expression * unary-expression #'build-binary-expression)
   (multiplicative-expression / unary-expression #'build-binary-expression)
   (multiplicative-expression % unary-expression #'build-binary-expression))

  (multiplicative-expression-no-bf
   unary-expression-no-bf
   (multiplicative-expression-no-bf * unary-expression #'build-binary-expression)
   (multiplicative-expression-no-bf / unary-expression #'build-binary-expression)
   (multiplicative-expression-no-bf % unary-expression #'build-binary-expression))

  (additive-expression
   multiplicative-expression
   (additive-expression + multiplicative-expression #'build-binary-expression)
   (additive-expression - multiplicative-expression #'build-binary-expression))

  (additive-expression-no-bf
   multiplicative-expression-no-bf
   (additive-expression-no-bf + multiplicative-expression #'build-binary-expression)
   (additive-expression-no-bf - multiplicative-expression #'build-binary-expression))

  (shift-expression
   additive-expression
   (shift-expression << additive-expression #'build-binary-expression)
   (shift-expression >> additive-expression #'build-binary-expression)
   (shift-expression >>> additive-expression #'build-binary-expression))

  (shift-expression-no-bf
   additive-expression-no-bf
   (shift-expression-no-bf << additive-expression #'build-binary-expression)
   (shift-expression-no-bf >> additive-expression #'build-binary-expression)
   (shift-expression-no-bf >>> additive-expression #'build-binary-expression))

  (relational-expression
   shift-expression
   (relational-expression < shift-expression #'build-binary-expression)
   (relational-expression > shift-expression #'build-binary-expression)
   (relational-expression <= shift-expression #'build-binary-expression)
   (relational-expression >= shift-expression #'build-binary-expression)
   (relational-expression instanceof shift-expression #'build-binary-expression)
   (relational-expression in shift-expression #'build-binary-expression))

  (relational-expression-no-in
   shift-expression
   (relational-expression-no-in < shift-expression #'build-binary-expression)
   (relational-expression-no-in > shift-expression #'build-binary-expression)
   (relational-expression-no-in <= shift-expression #'build-binary-expression)
   (relational-expression-no-in >= shift-expression #'build-binary-expression)
   (relational-expression-no-in instanceof shift-expression #'build-binary-expression))

  (relational-expression-no-bf
   shift-expression-no-bf
   (relational-expression-no-bf < shift-expression #'build-binary-expression)
   (relational-expression-no-bf > shift-expression #'build-binary-expression)
   (relational-expression-no-bf <= shift-expression #'build-binary-expression)
   (relational-expression-no-bf >= shift-expression #'build-binary-expression)
   (relational-expression-no-bf instanceof shift-expression #'build-binary-expression)
   (relational-expression-no-bf in shift-expression #'build-binary-expression))

  (equality-expression
   relational-expression
   (equality-expression == relational-expression #'build-binary-expression)
   (equality-expression != relational-expression #'build-binary-expression)
   (equality-expression === relational-expression #'build-binary-expression)
   (equality-expression !== relational-expression #'build-binary-expression))

  (equality-expression-no-in
   relational-expression-no-in
   (equality-expression-no-in == relational-expression #'build-binary-expression)
   (equality-expression-no-in != relational-expression #'build-binary-expression)
   (equality-expression-no-in === relational-expression #'build-binary-expression)
   (equality-expression-no-in !== relational-expression #'build-binary-expression))

  (equality-expression-no-bf
   relational-expression-no-bf
   (equality-expression-no-bf == relational-expression #'build-binary-expression)
   (equality-expression-no-bf != relational-expression #'build-binary-expression)
   (equality-expression-no-bf === relational-expression #'build-binary-expression)
   (equality-expression-no-bf !== relational-expression #'build-binary-expression))

  (bitwise-and-expression
   equality-expression
   (bitwise-and-expression & equality-expression #'build-binary-expression))

  (bitwise-and-expression-no-in
   equality-expression-no-in
   (bitwise-and-expression-no-in & equality-expression #'build-binary-expression))

  (bitwise-and-expression-no-bf
   equality-expression-no-bf
   (bitwise-and-expression-no-bf & equality-expression #'build-binary-expression))

  (bitwise-xor-expression
   bitwise-and-expression
   (bitwise-xor-expression ^ bitwise-and-expression #'build-binary-expression))

  (bitwise-xor-expression-no-in
   bitwise-and-expression-no-in
   (bitwise-xor-expression ^ bitwise-and-expression-no-in #'build-binary-expression))

  (bitwise-xor-expression-no-bf
   bitwise-and-expression-no-bf
   (bitwise-xor-expression-no-bf ^ bitwise-and-expression #'build-binary-expression))

  (bitwise-or-expression
   bitwise-xor-expression
   (bitwise-or-expression #\| bitwise-xor-expression #'build-binary-expression))

  (bitwise-or-expression-no-in
   bitwise-xor-expression-no-in
   (bitwise-or-expression-no-in #\| bitwise-xor-expression-no-in #'build-binary-expression))

  (bitwise-or-expression-no-bf
   bitwise-xor-expression-no-bf
   (bitwise-or-expression-no-bf #\| bitwise-xor-expression #'build-binary-expression))

  (logical-and-expression
   bitwise-or-expression
   (logical-and-expression && bitwise-or-expression #'build-logical-expression))

  (logical-and-expression-no-in
   bitwise-or-expression-no-in
   (logical-and-expression-no-in && bitwise-or-expression-no-in #'build-logical-expression))

  (logical-and-expression-no-bf
   bitwise-or-expression-no-bf
   (logical-and-expression-no-bf && bitwise-or-expression #'build-logical-expression))

  (logical-or-expression
   logical-and-expression
   (logical-or-expression || logical-and-expression #'build-logical-expression))

  (logical-or-expression-no-in
   logical-and-expression-no-in
   (logical-or-expression-no-in || logical-and-expression-no-in #'build-logical-expression))

  (logical-or-expression-no-bf
   logical-and-expression-no-bf
   (logical-or-expression-no-bf || logical-and-expression #'build-logical-expression))

  (conditional-expression
   logical-or-expression
   (logical-or-expression ? assignment-expression : assignment-expression #'build-conditional-expression))

  (conditional-expression-no-in
   logical-or-expression-no-in
   (logical-or-expression-no-in ? assignment-expression : assignment-expression-no-in #'build-conditional-expression))

  (conditional-expression-no-bf
   logical-or-expression-no-bf
   (logical-or-expression-no-bf ? assignment-expression : assignment-expression #'build-conditional-expression))

  (assignment-expression
   conditional-expression
   (left-hand-side-expression = assignment-expression #'build-assignment-expression)
   (left-hand-side-expression assignment-operator assignment-expression #'build-assignment-expression))

  (assignment-expression-no-in
   conditional-expression-no-in
   (left-hand-side-expression = assignment-expression-no-in #'build-assignment-expression)
   (left-hand-side-expression assignment-operator assignment-expression-no-in #'build-assignment-expression))

  (assignment-expression-no-bf
   conditional-expression-no-bf
   (left-hand-side-expression-no-bf = assignment-expression #'build-assignment-expression)
   (left-hand-side-expression-no-bf assignment-operator assignment-expression #'build-assignment-expression))

  (assignment-operator
   *= /= %= += -= <<= >>= >>>= &= ^= '|=' ; How to include this?
   )

  (expression
   assignment-expression
   (expression , assignment-expression (lambda (a b c)
					 (declare (ignore b))
					; If A is sequence-expression push C
					; else build-sequence-expression.
					 )))

  (expression-no-in
   assignment-expression-no-in
   (expression-no-in , assignment-expression-no-in (lambda (a b c)
						     (declare (ignore b))
					; The same!
						     )))

  (expression-no-bf
   assignment-expression-no-bf
   (expression-no-bf , assignment-expression (lambda (a b c)
					       (declare (ignore b))
					; Still the same!
					       )))

  (literal
   null-literal boolean-literal numeric-literal string-literal
   regular-expression-literal)

  (null-literal
   (null #'build-literal))

  (boolean-literal
   (true #'build-literal)
   (false #'build-literal))

  (numeric-literal
   (numeric #'build-literal))

  (string-literal
   (string #'build-literal))

  (regular-expression-literal
   (regular-expression-literal-begin regexp #'build-literal))

  (regular-expression-literal-begin
   ; TODO: How to handle regular expressions?
   /
   /=)

  (reserved-word
   break case catch continue debugger default delete do else finally for
   function if in instanceof new return switch this throw try typeof var
   void while with true false null class const enum export extends import super))
  
;; Test function, reads a valid javascript clip and returns an AST.
(defun parse (code)
  (parse-with-lexer (jsimple-lexer code)
		    *jsimple-parser*))
